\section{سوال پنجم - پروژه عملی}

در این پروژه، با نگاه به پروژه قبلی، بخش کانولوشن، یک سیستم پردازش تصویر طراحی می‌گردد. در این سیستم ورودی مربوط به دیتاست \lr{MNIST} با سایز ۲۸ در ۲۸ بوده و ۳ فیلتر کانولوشن به ابعاد ۳ در ۳ به صورت پشت سر هم بر روی تصویر اعمال می‌شود. مقادیر موجود در ماتریس‌های کانولوشن به صورت تصادفی انتخاب شده و به عنوان ورودی به تابع کانولوشن داده می‌شود (در کد \lr{Fix} نشده باشد) و خروجی با نمونه نرم‌افزاری مورد بررسی قرار می‌گیرد.

برای اطلاعات بیشتر می‌توانید از
\href{https://serokell.io/blog/introduction-to-convolutional-neural-networks}{این لینک}
استفاده کنید.

در گزارش ارسالی علاوه بر شرح مراحل کار با فرض استفاده از \lr{Zynq7010} میزان سرعت و تأخیر اولیه را گزارش نمایید. همچنین با فرض امکان گسترش که برای پردازش موازی چه تعداد از بلوک طراحی شده شما در این \lr{FPGA} قابل به کارگیری به صورت همزمان خواهد بود؟

\begin{qsolve}
	این پروژه را به دو قسمت نرم‌افزاری و سخت‌افزاری تقسیم می‌کنیم و در انتها پاسخ‌های این دو قسمت را باهم مقایسه می‌کنیم.
	
	
	\begin{enumerate}
		\item 
		\textbf{فاز نرم‌افزاری:}
		
		در این فاز ابتدا دیتاست \lr{MNIST} را لود کرده و به‌صورت رندوم از هر رقم یکی را انتخاب می‌کنیم و آن را نمایش می‌دهیم:
		
		\begin{center}
			\includegraphics*[width=1\linewidth]{pics/img2.png}
			\captionof{figure}{اعداد رندوم انتخاب شده}
			\label{ام‌نیست رندوم}
		\end{center}
		
		ضمن اینکه مقادیر پیکسل‌های این ۱۰ عدد تصویر را برای استفاده در فاز سخت‌افزاری، به‌صورت ماتریس‌های $28 \times 28 $ در فایل \texttt{.txt} ذخیره می‌کنیم.
		
		سپس با استفاده از ۳ کرنل زیر، عملیات کانولوشن را برای تمامی وروی‌ها به‌صورت متوالی انجام می‌دهیم.
		$$
		\left[ \begin{bmatrix} 0 & 1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, 
		\begin{bmatrix} 1 & 0 & 1 \\ 0 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix}, 
		\begin{bmatrix} 0 & 1 & 0 \\ 1 & 0 & 1 \\ 0 & 0 & 0 \end{bmatrix} \right]
		$$
		
		خروجی تصاویر کانوالو شده به‌صورت زیر ارائه می‌شود:
		
		\begin{center}
			\includegraphics*[width=1\linewidth]{pics/img3.png}
			\captionof{figure}{خروجی تصاویر کانوالو شده}
			\label{تصاویر کانوالو شده}
		\end{center}
		
		همچنین تصاویر خروجی را نیز در فایل \texttt{.txt} ذخیره می‌کنیم.
	\end{enumerate}
\end{qsolve}
\newpage
\begin{qsolve}
	\begin{enumerate}
		\item [2. ]
		\textbf{فاز سخت‌افزاری:}
		
		در این فاز ابتدا ماژول کانولوشن را در \lr{HLS} طراحی می‌کنیم و سپس در فایل \lr{Testbench} ورودی‌های تکست ذخیره‌شده در فاز نرم‌افزاری را به‌ترتیب می‌خوانیم و هر سه کرنل را به‌صورت پشت‌سرهم بر روی آن‌ها اعمال می‌کنیم. با توجه به ابعداد کرنل ها در هر مرحله از کانولوشن، از ابعاد تصویر کاسته می‌شود و نهایتا ابعاد تصویر خروجی پس از انجام هر سه کانولوشن می‌بایست $22 \times 22 $ باشد اما در این کد، ابعاد ورودی و خروجی را $28 \times 28 $ گرفته ایم. و پس از هر مرحله کانولوشن، به تعداد مورد تیاز به تصویر ورودی صفر اضافه می‌کنیم. (\lr{Zero Padding}).
		
		نهایتا پس از انجام محاسبات و مشاهده مشاهده پایان محاسبات در نرم‌افزار «شکل \ref{اتمام Simulation}»، به کد نوشته شده در فایل \texttt{txt2img.ipynb} می‌رویم تا به‌ترتیب تصاویر پردازش شده‌ای را که در فایل تکست ذخیره کرده‌ایم را بخوانیم و آن‌ها را نمایش دهیم تا بتوانیم با کد نرم‌افزاری مقایسه کنیم. 
		\begin{center}
			\includegraphics*[width=0.6\linewidth]{pics/img4.png}
			\captionof{figure}{اتمام \lr{Simulation}}
			\label{اتمام Simulation}
		\end{center}
		
		
		خروجی تصاویر کانوالو شده در ماژول \lr{HLS} به‌صورت زیر ارائه می‌شود:
		
		\begin{center}
			\includegraphics*[width=1\linewidth]{pics/img5.png}
			\captionof{figure}{تصاویر خروجی ماژول \lr{HLS}}
			\label{خروجی HLS}
		\end{center}
		
		همچنین ریپورت سنتز ماژول کانولوشن نیز به‌صورت زیر ارائه می‌شود:
		
	\end{enumerate}
\end{qsolve}

\begin{qsolve}
	\begin{center}
		\includegraphics*[width=1\linewidth]{pics/img6.png}
		\captionof{figure}{ریپورت سنتز \lr{HLS}}
		\label{ریپورت سنتز HLS}
	\end{center}
	
	بر اساس اطلاعات گزارش شده پس از سنتز، این ماژول ۲۵۶ عدد \lr{Flip Flop}،
	۸۱۸ عدد \lr{LUT} و ۶ عدد \lr{DSP} استفاده کرده است. همچنین \lr{Latency} ماژول ۳۳۹۰ سیکل کلاک و \lr{Interval}، ۳۳۹۱ گزارش شده است.
	
	مطابق با منابع موجود در تراشه \lr{ZYNQ 7010} که در جدول زیر آورده شده است، با فرض ثابت درنظر گرفتن شرایط طراحی و تعداد منابع مصرفی، بالغوه می‌توانیم تا سقف تعداد منابع تراشه از ماژول طراحی شده قرار دهیم اما موضوعی که مارا محدود می‌کند، میزان \lr{Interval} گزارش شده است که مقدار بالاییست و ما را در موازی سازی ماژول ها با یکدیگر مجدود می‌کند.
	
	برای رفع این مشکل، یکی از راه‌های ساده بدین صورت است که ابعاد ماژول کانولوشن را به $3 \times 3 $ کاهش دهیم. در این‌صورت، همزمان می‌توانیم تمام تصویر را با ماژول های کانولوشن $3 \times 3 $ پر کنیم و با سطح موازی سازی بالایی عملیات کانولوشن را انجام دهیم.
	
\end{qsolve}