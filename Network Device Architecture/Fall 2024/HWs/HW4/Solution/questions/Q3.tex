\section{سوال سوم}

با توجه به مدیریت صف با استفاده از تشخیص زودهنگام تصادفی (\lr{RED - Random Early Detection}):

\begin{enumerate}
	\item 
	توضیح دهید که چرا \lr{RED} به جلوگیری از شناسایی ترافیک \lr{TCP} از طریق فرستنده‌ها و کاهش هم‌زمان نرخ انتقال آن‌ها کمک می‌کند.
	
	\begin{qsolve}
		الگوریتم \lr{RED} به گونه‌ای طراحی شده است که با اعمال سیاست افت تصادفی بسته‌ها، از شناسایی الگوهای خاص توسط فرستنده‌های \lr{TCP} جلوگیری می‌کند:
		\begin{itemize}
			\item در \lr{RED}، بسته‌ها به صورت تصادفی و بر اساس طول متوسط صف (\lr{average queue length}) حذف می‌شوند.
			\item این حذف تصادفی به فرستنده‌های \lr{TCP} امکان نمی‌دهد که الگوهای ثابتی از افت بسته‌ها را شناسایی کرده و نرخ انتقال خود را همزمان کاهش دهند.
			\item این امر باعث می‌شود که جریان‌های \lr{TCP} به تدریج و نه ناگهانی، نرخ انتقال خود را تنظیم کنند و از کاهش شدید \lr{Throughput} شبکه جلوگیری شود.
		\end{itemize}
	\end{qsolve}
	
	
	\item 
	تأثیر \lr{RED} بر روی توان شبکه (\lr{Throughput}) را بررسی کنید.
	\begin{qsolve}
		\begin{itemize}
			\item \textbf{افزایش پایداری:} \lr{RED} با مدیریت فعالانه صف، از پر شدن کامل بافر و افت دسته‌جمعی بسته‌ها (\lr{Global Synchronization}) جلوگیری می‌کند.
			\item \textbf{بهبود \lr{Throughput}:} افت تصادفی بسته‌ها، منابع شبکه را به صورت عادلانه بین جریان‌های مختلف تقسیم می‌کند و \lr{Throughput} کلی شبکه را افزایش می‌دهد.
			\item \textbf{تأخیر کمتر:} کاهش احتمال پر شدن بافر باعث کاهش تأخیر در شبکه می‌شود، که به بهبود عملکرد جریان‌های حساس به تأخیر کمک می‌کند.
		\end{itemize}
	\end{qsolve}
	
	
	\item 
	پیچیدگی پیاده‌سازی الگوریتم \lr{RED} را بررسی کنید.
	
	\begin{qsolve}
		پیاده‌سازی \lr{RED} دارای پیچیدگی نسبی است:
		\begin{itemize}
			\item نیاز به محاسبه مداوم طول متوسط صف (\lr{average queue length}) با استفاده از فیلتر نمایی (\lr{Exponential Weighted Moving Average - EWMA}).
			\item تنظیم مقادیر پارامترهای کلیدی نظیر $Min_{th}$، $Max_{th}$ و احتمال افت بسته.
			\item نظارت پیوسته بر وضعیت صف و تصمیم‌گیری در مورد افت تصادفی بسته‌ها.
		\end{itemize}
		این پیچیدگی در مقایسه با روش‌های ساده مانند \lr{Tail Drop} بیشتر است، اما مزایای عملکردی آن در بسیاری از شبکه‌ها بر این پیچیدگی غلبه می‌کند.
		
	\end{qsolve}
\end{enumerate}
\newpage



\begin{enumerate}
	\item [4. ]
	توضیح دهید که اگر به جای استفاده از طول متوسط صف (\lr{average queue length}) از طول لحظه‌ای صف (\lr{instantaneous queue length}) استفاده شود، چه پیامد‌هایی خواهد داشت.
	
	\begin{qsolve}
		اگر از طول لحظه‌ای صف به جای طول متوسط صف استفاده شود:
		\begin{itemize}
			\item \textbf{رفتار ناپایدار:} تغییرات ناگهانی در طول صف باعث می‌شود افت بسته‌ها به صورت ناپایدار انجام شود.
			\item \textbf{افزایش احتمال حذف دسته‌جمعی بسته‌ها:} نوسانات لحظه‌ای طول صف می‌تواند منجر به حذف ناگهانی تعداد زیادی از بسته‌ها شود که عملکرد \lr{TCP} را مختل می‌کند.
			\item \textbf{کاهش پایداری شبکه:} استفاده از طول لحظه‌ای باعث کاهش پایداری و افزایش احتمال وقوع \lr{Global Synchronization} می‌شود.
		\end{itemize}
		
	\end{qsolve}
	
	
	
	\item [5. ]
	راه‌هایی برای پیدا کردن مقادیر معقول برای پارامترهای \lr{RED} (یعنی $Min_{th}$ و $Max_{th}$ و احتمال افت بسته زمانی که طول متوسط صف به $Max_{th}$​ می‌رسد) را بررسی کنید.
	\begin{qsolve}
		انتخاب مناسب پارامترهای \lr{RED} برای عملکرد بهینه شبکه حیاتی است:
		\begin{itemize}
			\item \textbf{مقدار $Min_{th}$:}
			\begin{itemize}
				\item باید کمتر از ۵۰٪ ظرفیت صف باشد.
				\item انتخاب خیلی کوچک باعث افت بیش از حد بسته‌ها می‌شود.
				\item انتخاب خیلی بزرگ باعث تأخیر بالا و پر شدن صف می‌شود.
			\end{itemize}
			\item \textbf{مقدار $Max_{th}$:}
			\begin{itemize}
				\item معمولاً بین \( 2 \times Min_{th} \) و \( 3 \times Min_{th} \) تنظیم می‌شود.
				\item باید به گونه‌ای باشد که از پر شدن کامل صف جلوگیری کند.
			\end{itemize}
			\item \textbf{احتمال افت بسته (\( P_{max} \)):}
			\begin{itemize}
				\item مقدار بین \( 0.01 \) تا \( 0.1 \) معمولاً مناسب است.
				\item مقدار خیلی بزرگ منجر به افت زیاد بسته‌ها و کاهش \lr{Throughput} می‌شود.
				\item مقدار خیلی کوچک باعث تأخیر و پر شدن صف می‌شود.
			\end{itemize}
			\item \textbf{تنظیم پویا:} استفاده از الگوریتم‌های تطبیقی برای تنظیم پویا مقادیر بر اساس ترافیک شبکه می‌تواند به بهبود عملکرد کمک کند.
		\end{itemize}
	\end{qsolve}
	
	
\end{enumerate}




