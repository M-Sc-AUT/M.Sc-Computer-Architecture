\section{سوال چهارم}

\begin{enumerate}
	\item 
	به چه دلیلی الگوریتم \lr{SJF} غیرقابل پیاده‌سازی در زمانبند کوتاه‌مدت است؟
	\begin{qsolve}
		الگوریتم \lr{SJF} به رغم اینکه به طور نظری بهترین عملکرد را از نظر \lr{turnaround time} دارد، در عمل غیرقابل پیاده‌سازی در زمان‌بند کوتاه‌مدت است به دلایل زیر:
		\begin{enumerate}
			\item 
			نیاز به پیش‌بینی \lr{:CPU Burst Time}\\
			الگوریتم \lr{SJF} برای انتخاب فرآیند بعدی که باید اجرا شود، به زمان پردازش باقی‌مانده هر فرآیند نیاز دارد. این زمان پردازش به طور دقیق باید پیش‌بینی شود تا بتوان فرآیندهایی با کمترین زمان پردازش را اولویت‌بندی کرد. در بسیاری از موارد، پیش‌بینی دقیق این زمان در زمان‌بند کوتاه‌مدت امکان‌پذیر نیست، زیرا نمی‌توان زمان دقیق پردازش هر فرآیند را قبل از شروع آن دانست.
			
			\item 
			اطلاعات مورد نیاز برای اجرای الگوریتم:\\
			برای اعمال \lr{SJF} به طور دقیق، سیستم باید از اطلاعات زمان پردازش فرآیندها به‌طور کامل آگاه باشد. این امر تنها در صورتی ممکن است که سیستم اطلاعات دقیقی از رفتار تمامی فرآیندها داشته باشد، که این اطلاعات معمولاً در زمان‌بند کوتاه‌مدت قابل دسترسی نیست. در سیستم‌های واقعی، زمان پردازش هر فرآیند ممکن است به صورت پویا تغییر کند، به‌ویژه در شرایطی که منابع دیگر (مثل ورودی/خروجی) همزمان در دسترس باشند.
			
			\item 
			زمان‌بندی در محیط‌های پیشرفته و \lr{multitasking}:\\
			در محیط‌های \lr{multitasking} که در آن فرآیندهای متعدد به طور هم‌زمان در حال اجرا هستند و سیستم باید به طور مداوم منابع را بین فرآیندها تقسیم کند، پیاده‌سازی \lr{SJF} بسیار پیچیده است. نیاز به محاسبه زمان پردازش باقی‌مانده و مرتب‌سازی پیوسته فرآیندها به منظور اولویت‌دهی، باعث ایجاد \lr{overhead} قابل توجه در سیستم می‌شود و کارایی سیستم را تحت تأثیر قرار می‌دهد.
			
			\item 
		دوری از اولویت‌دهی به فرآیندهای جدید:\\
		الگوریتم \lr{SJF} ممکن است باعث \lr{Starvation} شود، به این معنا که اگر فرآیندی زمان پردازش طولانی داشته باشد، ممکن است همیشه بعد از فرآیندهایی با زمان پردازش کوتاه‌تر قرار گیرد و به این ترتیب هیچ‌گاه اجرا نشود. این مشکل در سیستم‌هایی که فرآیندهای جدید به طور مداوم وارد صف می‌شوند، جدی‌تر می‌شود.
		\end{enumerate}
	\end{qsolve}
	
	
	\item 
	مزایا و معایب الگوریتم بانکداران چیست؟ توضیح دهید.
	\begin{qsolve}
		\begin{enumerate}
			\item \textbf{مزایا: }
			\begin{itemize}
				\item \textbf{جلوگیری از \lr{Deadlock}}: بزرگ‌ترین مزیت \lr{Banker's Algorithm} این است که از ایجاد \lr{Deadlock} جلوگیری می‌کند. با تجزیه و تحلیل وضعیت تخصیص منابع، سیستم می‌تواند اطمینان حاصل کند که فرآیندها هیچ‌گاه وارد وضعیت خطرناک نخواهند شد و بنابراین از \lr{Deadlock} جلوگیری می‌شود.
			\end{itemize}
		\end{enumerate}
	\end{qsolve}
\end{enumerate}
\newpage


\begin{qsolve}
	\begin{enumerate}
		\item [ ]
		\begin{itemize}
			
			\item \textbf{اعتماد به تخصیص‌های امن}: الگوریتم به سیستم اجازه می‌دهد تا تخصیص منابع را فقط در صورتی انجام دهد که مطمئن باشد سیستم همچنان قادر به انجام کارهای بعدی بدون خطر \lr{Deadlock} خواهد بود. این به سیستم کمک می‌کند تا منابع را به گونه‌ای تخصیص دهد که تمام فرآیندها قادر به تکمیل کار خود باشند.
			
			\item \textbf{انعطاف‌پذیری با تعداد فرآیندها و منابع}: این الگوریتم می‌تواند برای سیستم‌های با تعداد زیاد فرآیند و منابع به طور موثر استفاده شود. سیستم می‌تواند منابع را به طور پویا تخصیص دهد و همچنان وضعیت امن را حفظ کند.
			
			\item \textbf{پیش‌بینی در تخصیص منابع}: الگوریتم \lr{Banker's} به مدیر سیستم این امکان را می‌دهد که پیش‌بینی کند آیا تخصیص منابع در آینده باعث ایجاد مشکلاتی مانند \lr{Deadlock} خواهد شد یا نه. این ویژگی به بهینه‌سازی استفاده از منابع کمک می‌کند.
			
		\end{itemize}
		
		\item [(ب)] \textbf{معایب: }
		\begin{itemize}
			\item \textbf{پیچیدگی محاسباتی بالا}: یکی از معایب اصلی الگوریتم \lr{Banker's} این است که محاسبات آن پیچیده است. برای هر تخصیص منابع، باید وضعیت سیستم بررسی شود تا معلوم شود آیا وضعیت سیستم امن است یا نه. این بررسی‌ها شامل محاسبات زیادی هستند که به ویژه در سیستم‌هایی با تعداد زیادی فرآیند و منابع می‌تواند زمان‌بر باشد.
			
			\item \textbf{نیاز به اطلاعات دقیق}: الگوریتم \lr{Banker's} به اطلاعات دقیق و به روز در مورد نیازهای منابع فرآیندها نیاز دارد. این شامل اطلاعاتی درباره تعداد منابع مورد نیاز در هر لحظه و همچنین میزان منابع آزاد در سیستم است. جمع‌آوری و نگهداری این اطلاعات ممکن است پیچیده و زمان‌بر باشد.
			
			\item \textbf{\lr{Overhead} بالای پردازشی}: با توجه به اینکه الگوریتم باید وضعیت سیستم را به طور مداوم بررسی کند تا از \lr{Deadlock} جلوگیری کند، در سیستم‌های با بار کاری سنگین، این بررسی‌ها می‌تواند باعث افزایش \lr{overhead} شود که کارایی سیستم را کاهش می‌دهد.
			
			\item \textbf{ممکن است باعث کاهش کارایی شود}: برای اطمینان از وضعیت امن، گاهی ممکن است تخصیص منابع به برخی فرآیندها به تأخیر بیفتد، حتی اگر این تخصیص‌ها ضروری نباشند. این می‌تواند منجر به کاهش کارایی و عدم استفاده بهینه از منابع شود.
			
			\item \textbf{ممکن است منجر به \lr{Starvation} شود}: اگر یک فرآیند همیشه در حال انتظار برای تخصیص منابع باشد (چرا که همیشه تخصیص آن باعث وضعیت خطرناک می‌شود)، ممکن است \lr{starvation} رخ دهد. به این معنی که یک فرآیند به دلیل تخصیص منابع به فرآیندهای دیگر، هرگز منابع مورد نیاز خود را دریافت نکند.
			
			\item \textbf{نیاز به پیش‌بینی نیازهای آینده}: الگوریتم \lr{Banker's} نیاز به پیش‌بینی منابع مورد نیاز فرآیندها در آینده دارد. این امر در بسیاری از موارد عملی نیست، زیرا بسیاری از فرآیندها نیازهای خود را به طور پویا و در طول زمان تغییر می‌دهند.
		\end{itemize}
	\end{enumerate}
\end{qsolve}


\begin{enumerate}
	\item [3. ]
	روش‌های بازیابی از بن‌بست چیست؟ این روش‌ها را شرح دهید و با یکدیگر مقایسه کنید.
\end{enumerate}
\newpage

\begin{qsolve}
	\begin{enumerate}
		\item {\lr{:Process Termination}}
		در این روش، سیستم یکی از فرآیندهای درگیر در \lr{Deadlock} را خاتمه می‌دهد تا منابع آن آزاد شوند و \lr{Deadlock} رفع شود. این روش می‌تواند به دو صورت انجام شود:
		\begin{enumerate}
			\item \textbf{خاتمه فرآیندها به ترتیب انتخابی}: فرآیندهایی که کمترین اولویت دارند یا کمترین هزینه‌ را برای سیستم دارند خاتمه داده می‌شوند.
			\item \textbf{خاتمه تمامی فرآیندهای درگیر در \lr{Deadlock}}: تمام فرآیندهایی که در وضعیت \lr{Deadlock} هستند خاتمه می‌یابند.
		\end{enumerate}
		
		\textbf{مزایا}:
		\begin{itemize}
			\item ساده و سریع است.
			\item برطرف کردن فوری \lr{Deadlock} بدون نیاز به تغییرات پیچیده در وضعیت سیستم.
		\end{itemize}
		
		\textbf{معایب}:
		\begin{itemize}
			\item ممکن است باعث از دست رفتن داده‌ها و کارهای نیمه‌تمام فرآیندها شود.
			\item در صورت انتخاب اشتباه فرآیند، ممکن است سیستم کارآیی خود را از دست بدهد.
			\item ممکن است هزینه زیادی از نظر زمان و منابع داشته باشد.
		\end{itemize}
		
		\item \lr{:Resource Preemption}
		در این روش، منابع از فرآیندهایی که در وضعیت \lr{Deadlock} قرار دارند بازپس‌گیری می‌شود و به فرآیندهای دیگر اختصاص می‌یابد. این روش معمولاً برای آزادسازی منابع از فرآیندهایی که کمترین نیاز را به آن‌ها دارند استفاده می‌شود.
		
		\textbf{مزایا}:
		\begin{itemize}
			\item فرآیندها می‌توانند به اجرای خود ادامه دهند و \lr{Deadlock} رفع می‌شود.
			\item در صورتی که منابع به درستی بازپس‌گیری شوند، فرآیندهای دیگر می‌توانند از آن‌ها بهره‌برداری کنند.
		\end{itemize}
		
		\textbf{معایب}:
		\begin{itemize}
			\item باعث \lr{Starvation} می‌شود، چون ممکن است منابع به فرآیندهای دیگر اختصاص یابد و فرآیندهای درگیر در \lr{Deadlock} همیشه منتظر بمانند.
			\item ممکن است به داده‌های مهم فرآیندها آسیب برسد.
			\item هزینه‌های زیادی برای مدیریت و زمان‌بندی منابع دارد.
		\end{itemize}
		
		
		\item \lr{:Process Rollback}
		در این روش، سیستم فرآیندهایی را که در \lr{Deadlock} قرار دارند به وضعیت قبلی خود بازمی‌گرداند. این کار معمولاً با استفاده از \lr{checkpointing} (نقطه‌چک) انجام می‌شود، که در آن وضعیت‌ها و داده‌های مربوط به فرآیندها ذخیره می‌شوند. زمانی که \lr{Deadlock} شناسایی می‌شود، سیستم فرآیند را به آخرین وضعیت ذخیره‌شده بازمی‌گرداند.
		
		\textbf{مزایا}:
		\begin{itemize}
			\item اطلاعات از دست نمی‌رود و فرآیندها به صورت کامل بازیابی می‌شوند.
			\item در صورت استفاده صحیح از نقاط ذخیره‌سازی (\lr{checkpoints})، سیستم می‌تواند بدون از دست رفتن داده‌ها بازیابی شود.
		\end{itemize}
	\end{enumerate}
\end{qsolve}
\newpage

\begin{qsolve}
	\begin{enumerate}
		\item [ ]
				
		\textbf{معایب}:
		\begin{itemize}
			\item به هزینه ذخیره‌سازی و مدیریت نیاز دارد.
			\item ممکن است زمان‌بری باشد، به خصوص اگر فرآیندها حجم داده‌های زیادی را ذخیره کنند.
			\item \lr{Rollback} ممکن است به \lr{Deadlock} جدیدی منجر شود.
		\end{itemize}
		
		
		\item \lr{:Killing the Resources}
		در این روش، به جای خاتمه دادن به فرآیندها، سیستم تمام منابعی که باعث \lr{Deadlock} شده‌اند را آزاد می‌کند. به این معنی که منابع درگیر در \lr{Deadlock} به طور کلی آزاد شده و به سایر فرآیندها اختصاص داده می‌شود.
		
		\textbf{مزایا}:
		\begin{itemize}
			\item ساده و سریع است.
			\item موجب آزادسازی فوری منابع می‌شود.
		\end{itemize}
		
		\textbf{معایب}:
		\begin{itemize}
			\item موجب اتلاف منابع می‌شود.
			\item ممکن است تغییرات زیادی در وضعیت سیستم ایجاد کند.
		\end{itemize}
		
		
		و در‌نهایت در جدول زیر مقایسه‌ای از این روش‌ها را ارائه می‌دهم:
		
		
		
		\begin{table}[h!]
			\centering
			\resizebox{\textwidth}{!}{ % تغییر اندازه جدول
				\begin{tabular}{|c|c|c|}
					\hline
					\textbf{روش}                     & \textbf{مزایا}                                 & \textbf{معایب}                                 \\ \hline
					\lr{Process Termination}          & ساده و سریع، حل فوری \lr{Deadlock}           & ممکن است داده‌ها از دست بروند، هزینه زیاد در انتخاب فرآیند  \\ \hline
					\lr{Resource Preemption}          & فرآیندها می‌توانند ادامه دهند، بازگشت منابع  & ممکن است باعث \lr{Starvation} و آسیب به داده‌ها شود \\ \hline
					\lr{Process Rollback}             & اطلاعات از دست نمی‌رود، بازیابی دقیق         & هزینه ذخیره‌سازی بالا، ممکن است به \lr{Deadlock} جدید منجر شود \\ \hline
					\lr{Killing the Resources}       & آزادسازی فوری منابع                          & موجب اتلاف منابع، تغییرات زیاد در وضعیت سیستم   \\ \hline
				\end{tabular}
			}
			\caption{مقایسه روش‌های بازیابی از \lr{Deadlock}}
		\end{table}
	\end{enumerate}
\end{qsolve}








%
%
%\section*{مزایا و معایب الگوریتم \lr{Banker's Algorithm}}
%
%\subsection*{مزایا}
%
%
%\subsection*{معایب}
