\section{سوال سوم}

در رابطه با نواحی بحرانی به سوالات زیر پاسخ دهید.

\begin{enumerate}
	\item 
	دستورات Atomic به چه دستوراتی گفته می‌شود؟
	
	\begin{qsolve}
	به دستوراتی گفته می‌شود که به صورت کامل و بدون وقفه توسط فرآیند اجرا می‌شوند و نمی‌توان آن‌ها را به بخش‌های کوچکتری تقسیم کرد. این دستورات یا به‌طور کامل اجرا می‌شوند یا اصلاً اجرا نمی‌شوند، بنابراین در زمان اجرای آن‌ها، هیچ فرآیند یا رشته دیگری نمی‌تواند به منابع مشترک دسترسی پیدا کند یا آن‌ها را تغییر دهد.
	\end{qsolve}
	
	
	\item 
	دو مورد از برتری‌های استفاده از \lr{Semaphore} به‌جای \lr{Mutex} را توضیح دهید.
	
	\begin{qsolve}
		دو مورد از برتری‌های \lr{Semaphore} نسبت به \lr{Mutex} عبارت است از:
		
		\begin{enumerate}
			\item 
			\textbf{قابلیت استفاده برای همگام‌سازی چندین فرآیند:}
			\lr{Semaphore}‌ها می‌توانند به عنوان یک شمارنده استفاده شوند و به تعداد بیش از یک فرآیند اجازه دسترسی به منبع مشترک را بدهند. برای مثال، اگر یک منبع خاص ظرفیت استفاده توسط چندین فرآیند به‌طور همزمان را داشته باشد (مانند یک محدوده حافظه با دسترسی چندگانه)، \lr{Semaphore}‌ها می‌توانند برای مدیریت این حالت استفاده شوند، اما \lr{Mutex} فقط برای کنترل دسترسی یک فرآیند در هر زمان مناسب است.
			
			
			\item
			\textbf{پشتیبانی از \lr{Interprocess Synchronization}:}
			\lr{Semaphore}‌ها می‌توانند برای همگام‌سازی بین پردازه‌ها استفاده شوند، در حالی که \lr{Mutex}‌ها معمولاً فقط در همگام‌سازی بین رشته‌ها در یک فرآیند به‌کار می‌روند. این ویژگی باعث می‌شود Semaphore برای سناریوهایی که پردازه‌های جداگانه در یک سیستم نیاز به هماهنگی دارند مناسب‌تر باشد.
		\end{enumerate}
	\end{qsolve}
	
	
	
	\item 
	الگوریتم پترسون را برای پشتیبانی از \lr{N} فرآیند بازنویسی کنید و سپس برقراری سه شرط \lr{Mutual exclusion}  و\lr{Progress} و \lr{Bounded waiting} را در الگوریتم خود بررسی کنید.
	
	\begin{qsolve}
		برای پشتیبانی از تعداد \lr{N} فرآیند، می‌توان الگوریتم پترسون را به صورت زیر بازنویسی کرد:	
	\end{qsolve}	
\end{enumerate}

\begin{qsolve}
\begin{latin}
\begin{lstlisting}[caption=N process Peterson algorithm, label=cpp_code_example]
bool flag[N];
int turn;

void enter_critical_section(int i)
{
	flag[i] = true;
	turn = i;
	for (int j = 0; j < N; j++) 
	{
		if (j != i) 
		{
			while (flag[j] && turn == i) 
			{
				/* wait until it's process i's turn.  */
			}
		}
	}
}

void exit_critical_section(int i)
{
	flag[i] = false;
}
\end{lstlisting}
\end{latin}	

\begin{enumerate}
	\item 
	\textbf{شرط \lr{Mutual Exclusion}:}
	در این الگوریتم، شرطی وجود دارد که هر فرآیند قبل از ورود به ناحیه بحرانی بررسی می‌کند. اگر هیچ فرآیند دیگری در ناحیه بحرانی نباشد، آن فرآیند اجازه ورود پیدا می‌کند. بنابراین، همیشه تنها یک فرآیند در هر لحظه می‌تواند در ناحیه بحرانی باشد.
	
	\item 
	\textbf{شرط \lr{Progress}:}
	اگر هیچ فرآیند‌ای در ناحیه بحرانی نباشد و چندین فرآیند آماده‌ی ورود باشند، نوبت‌دهی در این الگوریتم تضمین می‌کند که یکی از فرآیند‌های آماده می‌تواند وارد ناحیه بحرانی شود، به شرطی که شرایط برایش مهیا باشد. این مسئله شرط پیشرفت را برقرار می‌کند.
	
	
	\item 
	\textbf{شرط \lr{Bounded Waiting}:}
	این الگوریتم تضمین می‌کند که هر فرآیند پس از تعداد محدودی از چرخش‌ها در حلقه، می‌تواند وارد ناحیه بحرانی شود. با توجه به تغییر \lr{turn} در حلقه، هیچ فرآیند‌ای به طور نامحدود منتظر نمی‌ماند. بنابراین شرط انتظار محدود نیز برقرار است.	
	
	
	
\end{enumerate}
\end{qsolve}


