\section{سوال اول}

به سوالات زیر در رابطه با محیط‌های محاسباتی (\lr{Computing environment}) پاسخ دهید.

\begin{enumerate}
	\item 
	مدل‌های \lr{Client-server} و \lr{Peer to peer} را تعریف و با یکدیگر مقایسه کنید.
	
	\begin{qsolve}
		\begin{enumerate}
			\item 
			\textbf{معماری \lr{Client-server}: }\\
			در این مدل، سیستم به دو بخش اصلی تقسیم می‌شود: کلاینت (\lr{Client}) و سرور (\lr{Server}).
			سرور یک سیستم قدرتمند است که خدمات یا منابع خاصی مانند پایگاه‌داده، فایل‌ها، یا اپلیکیشن‌ها را ارائه می‌دهد و کلاینت‌ها دستگاه‌هایی هستند که از این منابع استفاده می‌کنند. ارتباط معمولاً به این شکل است که کلاینت‌ها درخواست‌هایی به سرور می‌فرستند و سرور پاسخ می‌دهد. برای مثال زمانی که ما از مرورگر خود به وب‌سایتی دسترسی پیدا می‌کنیم، مرورگر به عنوان کلاینت و وب‌سرور به عنوان سرور عمل می‌کند.
			
			مطابق با توضیحات صفحه ۴۳ کتاب \lr{Silberschatz} می‌توان گفت معماری شبکه‌های امروزی معمولاً به این شکل است. به این مدل از سیستم‌های توزیع‌شده، سیستم کلاینت-سرور می‌گویند. همچنین سرورها به دو دسته تقسیم می‌شوند: سرورهای محاسباتی و سرورهای فایل. که چون در صورت سوال توضیحات سرور ها خواسته نشده است، توضیحات آن را نمی‌نویسیم.
			
			شکل زیر که از کتاب \lr{Silberschatz} آورده شده است، ساختار مدل کلاینت-سرور را نشان می‌دهد.
			
			\begin{center}
				\includegraphics*[width=0.7\linewidth]{pics/img1.png}
				\captionof{figure}{ساختار سیستم‌هایی با مدل کلاینت-سروری}
			\end{center}


			
			\item 
			\textbf{معماری \lr{Peer to peer}: }\\
			مدل دیگری که برای سیستم‌های توزیع‌شده وجود دارد، مدل \lr{P2P} است. در این مدل، تفاوتی بین کلاینت‌ها و سرورها وجود ندارد یعنی هر گره برحسب خدمتی که ارائه می‌دهد، می‌تواند هم به عنوان کلاینت و هم به عنوان سرور عمل کند. شکل زیر نمونه‌ای از این معماری است:
		\end{enumerate}
	\end{qsolve}
	
	
	\begin{qsolve}
		\begin{enumerate}
			\item [ ]
			\begin{center}
				\includegraphics*[width=0.5\linewidth]{pics/img2.png}
				\captionof{figure}{ساختار سیستم‌هایی با مدل \lr{P2P}}
			\end{center}
			
			
			 سیستم‌های \lr{P2P} نسبت به سیستم‌های کلاینت-سرور مزیتی دارند. در سیستم کلاینت-سرور، سرور می‌تواند یک گلوگاه باشد؛ اما در سیستم \lr{P2P} خدمات توسط چندین گره که در شبکه توزیع شده‌اند ارائه می‌شوند. همچنین \lr{Scaleability} در مدل \lr{P2P} بهتر است، چون با افزایش تعداد دستگاه‌ها، شبکه قوی‌تر می‌شود. در حالی که در مدل \lr{Client-server}، با افزایش تعداد کلاینت‌ها، سرور ممکن است تحت فشار قرار گیرد. از نظر امنیت مدل کلاینت سرور راحت تر مدیریت می‌شود چون یک سرور مرکزی می‌تواند کنترل کامل بر روی داده‌ها و دسترسی داشته باشد، در حالی که در مدل \lr{P2P} امنیت پیچیده‌تر است چون داده‌ها در میان بسیاری از دستگاه‌ها پخش می‌شوند.
			 
اسکایپ نمونه‌ای از مدل \lr{P2P} است.
		\end{enumerate}
	\end{qsolve}
	
	
	
	
	
	\item 
	 \lr{Virtualization} 
	و \lr{Emulation} را تعریف کنید و تفاوت‌های آن‌ها را ذکر کنید.
	
	\begin{qsolve}
		مطابق با تعریف آقای \lr{}Silberschatz در صفحه ۳۴ کتابشان، می‌توان گفت که: مجازی‌سازی یا \lr{Virtualization} یک فناوری است که به ما این امکان را می‌دهد تا سخت‌افزار یک کامپیوتر (مانند پردازنده، حافظه، دیسک‌های سخت، کارت‌های شبکه و غیره) را به چندین محیط اجرایی مختلف تجزیه کنیم و به این ترتیب، این حس برای کاربر ایجاد شود که هر محیط به‌صورت مجزا روی یک کامپیوتر اختصاصی خود در حال اجرا است. این محیط‌ها می‌توانند به‌عنوان سیستم‌عامل‌های مختلف (مثل ویندوز و یونیکس) در نظر گرفته شوند که ممکن است هم‌زمان اجرا شوند و با هم تعامل داشته باشند. کاربر یک ماشین مجازی می‌تواند بین این سیستم‌عامل‌های مختلف به همان شکلی که بین فرآیندهای مختلف در یک سیستم‌عامل واحد جابه‌جا می‌شود، جابه‌جا شود.
		
		مجازی‌سازی به سیستم‌عامل‌ها این امکان را می‌دهد که به‌عنوان برنامه‌هایی در درون دیگر سیستم‌عامل‌ها اجرا شوند. در نگاه اول، ممکن است این قابلیت چندان کاربردی به نظر نرسد، اما صنعت مجازی‌سازی بسیار گسترده و در حال رشد است که نشان‌دهنده اهمیت و کاربرد فراوان آن است.
		
		به طور کلی، نرم‌افزارهای مجازی‌سازی یکی از اعضای گروهی از نرم‌افزارها هستند که شبیه‌سازی (\lr{Emulation}) نیز در آن قرار می‌گیرد. \lr{Emulation} به معنای شبیه‌سازی سخت‌افزار کامپیوتر در نرم‌افزار است و معمولاً زمانی استفاده می‌شود که نوع پردازنده مبدأ با پردازنده هدف متفاوت باشد. به عنوان مثال، زمانی که شرکت اپل پردازنده‌های \lr{IBM Power} خود را به پردازنده \lr{Intel x86} برای کامپیوترهای دسکتاپ و لپ‌تاپ خود تغییر داد یک قابلیت شبیه‌سازی به نام \lr{Rosetta} ارائه داد که به برنامه‌هایی که برای پردازنده \lr{IBM} نوشته شده بودند، اجازه می‌داد روی پردازنده \lr{Intel} اجرا شوند. 
		
	\end{qsolve}
	
	
	
	\begin{qsolve}
			این مفهوم می‌تواند توسعه یابد تا به یک سیستم‌عامل کامل که برای یک پلتفرم خاص نوشته شده، اجازه دهد روی یک پلتفرم دیگر اجرا شود. با این حال، شبیه‌سازی هزینه بالایی دارد، زیرا هر دستورالعمل در سطح ماشین که به‌طور بومی روی سیستم مبدأ اجرا می‌شود، باید به دستورالعمل معادل در سیستم هدف ترجمه شود، که اغلب منجر به چندین دستورالعمل در سیستم هدف می‌شود. اگر پردازنده‌های مبدأ و هدف سطح عملکرد مشابهی داشته باشند، ممکن است کد شبیه‌سازی‌شده بسیار کندتر از کد بومی اجرا شود. شکل زیر نمونه ای از یک کامپیوتر معمولی و یک کامپیوتر مجازی شده را نشان می‌دهد:
			
		\begin{center}
			\includegraphics*[width=0.7\linewidth]{pics/img3.png}
			\captionof{figure}{ساختار یک ۳ عدد \lr{VM}}
		\end{center}
	\end{qsolve}
	
	
	
	\item 
	سه نمونه از دسته سرویس‌های ابری را نام ببرید و به صورت مختصر توضیح دهید.
	
	\begin{qsolve}
		\begin{enumerate}
			\item 
			\lr{\textbf{:(SaaS) Software as a service}}\\
			یک یا چند برنامه (مانند پردازشگرهای کلمه یا \lr{spreadsheets}) که از طریق اینترنت در دسترس هستند.
			
			\item
			\lr{\textbf{:(PaaS) Platform as a service}}\\
			یک پشته نرم‌افزاری آماده برای استفاده از طریق اینترنت (به عنوان مثال، یک سرور پایگاه داده).
			
			
			\item 
			\lr{\textbf{:(IaaS) Infrastructure as a service}}\\
			سرورها یا فضای ذخیره‌سازی که از طریق اینترنت قابل دسترسی هستند (برای مثال، فضای ذخیره‌سازی برای تهیه نسخه‌های پشتیبان از داده‌های تولید).
				
				
		\end{enumerate}
		
	\end{qsolve}
\end{enumerate}