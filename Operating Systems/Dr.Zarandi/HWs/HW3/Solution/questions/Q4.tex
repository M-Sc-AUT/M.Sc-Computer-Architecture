\section{سوال چهارم}


انواع مدل‌های طراحی سیستم‌های عامل را نام ببرید و به صورت مختصر ساختار آن‌ها را نیز توضیح دهید.

\begin{qsolve}
	
	بر اساس تقسیم‌بندی آقای \lr{} می‌توان طراحی سیستم‌های عامل را به گروه‌های زیر تقسیم نمود:
	
	\begin{enumerate}
		\item 
		\lr{\textbf{:Monolithic}}\\
		ساده‌ترین ساختار برای سازماندهی یک سیستم‌عامل، نبود هیچ ساختاری است. یعنی تمام عملکردهای هسته را در یک فایل باینری واحد و ایستا که در یک فضای آدرس اجرا می‌شود، قرار دهیم.
		در این مدل، کل سیستم عامل به عنوان یک واحد پیوسته طراحی شده است. همه عملکردها و سرویس‌ها در یک هسته بزرگ قرار می‌گیرند و این هسته تمام وظایف سیستم عامل را مدیریت می‌کند.
		تمام سرویس‌ها (مانند مدیریت حافظه، زمان‌بندی فرآیندها، مدیریت فایل و ...) در یک لایه قرار دارند و کرنل مسئول اجرای مستقیم این سرویس‌هاست. تمامی بخش‌های سیستم به یکدیگر متصل هستند و هر بخش می‌تواند به بخش‌های دیگر دسترسی داشته باشد.
		
		\begin{itemize}
			\item
			مزایا: سرعت بالا به دلیل نبود واسطه‌های اضافی.
			
			\item 
			معایب: به دلیل یکپارچه بودن، خطا در یک بخش می‌تواند کل سیستم را تحت تأثیر قرار دهد و دیباگ کردن سیستم پیچیده است.
		\end{itemize}
		
		
		
		
		
		
		\item 
		\lr{\textbf{:Layered}}\\
		رویکرد یکپارچه اغلب به‌عنوان یک سیستم به‌هم‌پیوسته شناخته می‌شود، زیرا تغییرات در یک بخش از سیستم می‌تواند تأثیرات گسترده‌ای روی بخش‌های دیگر داشته باشد. در مقابل، می‌توانیم سیستمی طراحی کنیم که به‌طور جداگانه به‌هم‌پیوسته است. چنین سیستمی به اجزای جداگانه و کوچک‌تری تقسیم می‌شود که عملکردهای خاص و محدودی دارند. همه این اجزا با هم هسته را تشکیل می‌دهند. مزیت این رویکرد ماژولار این است که تغییرات در یک جزء تنها بر همان جزء تأثیر می‌گذارد و دیگر اجزا را تحت‌تأثیر قرار نمی‌دهد، که به مجریان سیستم آزادی بیشتری در ایجاد و تغییرات داخلی سیستم می‌دهد. یکی از روش‌های ماژولار کردن سیستم، رویکرد لایه‌ای است، که در آن سیستم‌عامل به تعدادی لایه (سطح) تقسیم می‌شود. لایه پایین (لایه ۰) سخت‌افزار است و بالاترین لایه (لایه \lr{N}) رابط کاربری است. هر لایه یک عملکرد خاص دارد و هر لایه تنها به لایه‌های پایین‌تر خود دسترسی دارد و از لایه‌های بالاتر مستقل است. لایه‌های بالاتر از طریق لایه‌های پایین‌تر به سخت‌افزار دسترسی پیدا می‌کنند.
		
		
		\begin{itemize}
			\item
			مزایا: طراحی منظم و ساده‌تر برای مدیریت و دیباگ کردن، چرا که هر لایه وظایف محدودی دارد.
			
			\item 
			معایب: کندتر بودن نسبت به سیستم‌های تک‌لایه‌ای به دلیل وجود واسطه بین لایه‌ها.
		\end{itemize}
		
		شکل زیر ساختار این مدل است:
		
		
	\end{enumerate}
\end{qsolve}




\begin{qsolve}
	\begin{enumerate}
		\item [ ]
		\begin{center}
			\includegraphics*[width=0.4\linewidth]{pics/img5.png}
			\captionof{figure}{ساختار لایه‌ای}
		\end{center}
		
		
		
		
		\item [3.]
		\lr{\textbf{:Microkernels}}\\
		در مدل ریزهسته‌ای، هسته ماژولار شده است. یعنی تمام اجزای غیرضروری از هسته حذف و به‌عنوان برنامه‌های سطح کاربر در فضاهای آدرس جداگانه پیاده‌سازی شدند. نتیجه آن کوچکتر شدن هسته است. در مورد اینکه کدام خدمات باید در هسته باقی بمانند و کدام باید در فضای کاربر پیاده‌سازی شوند، توافق چندانی وجود ندارد. به‌طور معمول، ریز هسته‌ها مدیریت حداقلی پردازش و حافظه را همراه با یک امکان ارتباطی فراهم می‌کنند
				
		\begin{itemize}
			\item
			مزایا: ایمنی و پایداری بالاتر؛ چرا که خطا در یکی از سرویس‌ها بر کل سیستم تأثیر نمی‌گذارد.
			
			\item 
			معایب: عملکرد کندتر به دلیل نیاز به پیام‌رسانی بین سرویس‌های مختلف.
		\end{itemize}
		
		شکل زیر ساختار این مدل است:
		\begin{center}
			\includegraphics*[width=0.8\linewidth]{pics/img6.png}
			\captionof{figure}{ساختار ریز‌هسته}
		\end{center}
		
		
		\item [4.]
		\lr{\textbf{:Modules}}\\
		یکی از بهترین روش‌های طراحی سیستم‌عامل در حال حاضر، استفاده از ماژول‌های بارگذاری‌شونده هسته (\lr{LKMs}) است. در این طراحی، هسته شامل مجموعه‌ای از اجزای اصلی است و می‌تواند خدمات اضافی را از طریق ماژول‌ها، در زمان بوت یا حین اجرا، لینک کند. 
	\end{enumerate}
\end{qsolve}








\begin{qsolve}
	\begin{enumerate}
		\item [ ]
		این نوع طراحی در بسیاری از پیاده‌سازی‌های مدرن \lr{UNIX} مانند لینوکس، \lr{macOS}، و سولاریس و همچنین ویندوز رایج است. ایده این طراحی این است که هسته خدمات اصلی را ارائه دهد، در حالی که سایر خدمات به‌طور پویا در حین اجرای هسته پیاده‌سازی می‌شوند. لینوکس به‌طور گسترده از ماژول‌های بارگذاری‌شونده برای پشتیبانی از درایورهای دستگاه‌ها و سیستم‌های فایل استفاده می‌کند. این ماژول‌ها می‌توانند در حین اجرا به هسته اضافه یا حذف شوند و عملکرد هسته پویا و ماژولار را فراهم کنند، در حالی که مزایای عملکردی سیستم‌های یکپارچه را نیز حفظ می‌کنند.
		
		\begin{itemize}
			\item
			مزایا: انعطاف‌پذیری بیشتر و قابلیت گسترش سیستم عامل بدون نیاز به بازطراحی کل سیستم.
			
			\item 
			معایب: پیچیدگی بیشتر در مدیریت ماژول‌ها.
		\end{itemize}
		
		
		
		
		\item [5.]
		\lr{\textbf{:Hybrid}}\\
		در عمل، تعداد بسیار کمی از سیستم‌عامل‌ها از یک ساختار تعریف‌شده و واحد استفاده می‌کنند. در عوض، آن‌ها ترکیبی از ساختارهای مختلف را به کار می‌گیرند و به سیستم‌های ترکیبی تبدیل می‌شوند که به مسائل مربوط به عملکرد، امنیت، و کاربرپسندی رسیدگی می‌کنند. به عنوان مثال، لینوکس یک سیستم یکپارچه است، زیرا داشتن سیستم‌عامل در یک فضای آدرس واحد عملکرد بسیار بالایی را فراهم می‌کند. با این حال، لینوکس ماژولار است و امکان افزودن قابلیت‌های جدید به‌طور پویا به هسته را فراهم می‌کند. ویندوز نیز عمدتاً یکپارچه است، اما برخی از ویژگی‌های سیستم‌های ریز هسته‌ای را حفظ کرده است، مانند پشتیبانی از زیرسیستم‌های جداگانه که به‌عنوان فرآیندهای حالت کاربر اجرا می‌شوند.
		
		
		
		\begin{itemize}
			\item
			مزایا: استفاده از مزایای هر روش :)
			
			\item 
			معایب: -
		\end{itemize}
	\end{enumerate}
\end{qsolve}











