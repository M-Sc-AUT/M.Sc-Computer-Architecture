\section{سوال اول}

به سوالات زیر پاسخ دهید.

\begin{enumerate}
	\item 
	مزایای استفاده از ریسمان‌ها در مقابل فرایندها چیست؟
	\begin{qsolve}
		\begin{enumerate}
			\item 
			\textbf{اشتراک منابع:} ریسمان‌ها در یک فرایند به حافظه و منابع مشترکی دسترسی دارند، مانند فضای آدرس، فایل‌ها و متغیرهای سراسری. این امر ارتباط و انتقال داده‌ها بین ریسمان‌ها را ساده‌تر و سریع‌تر از فرایندها می‌کند، چرا که نیازی به کپی کردن داده‌ها بین فضای آدرس‌های جداگانه نیست.
		
		
			\item 
			\textbf{کارایی بالاتر و سربار کمتر:} ایجاد و ازبین بردن ریسمان‌ها به‌مراتب کم‌هزینه‌تر از فرایندها است. به دلیل این که ریسمان‌ها فضای آدرس مشترک دارند، سیستم‌عامل برای سوئیچ کردن بین ریسمان‌ها نیازی به تغییر کامل فضای آدرس (\lr{Context Switching}) ندارد. این امر سربار کمتری روی سیستم ایجاد کرده و کارایی را افزایش می‌دهد.
			
			
			\item 
			\textbf{بهبود عملکرد در سیستم‌های چندپردازنده‌ای:} ریسمان‌ها می‌توانند به‌طور هم‌زمان در پردازنده‌های مختلف اجرا شوند. با استفاده از ریسمان‌ها، یک برنامه می‌تواند از چندین پردازنده به‌طور مؤثرتری بهره ببرد و کارایی کلی افزایش یابد.
			
			
			\item 
			\textbf{پشتیبانی بهتر از هم‌روندی (\lr{Concurrency}):} ریسمان‌ها امکان اجرای موازی چندین تسک را در یک برنامه فراهم می‌کنند، که این موضوع به‌ویژه برای برنامه‌های بلادرنگ و برنامه‌هایی که به پاسخگویی سریع نیاز دارند، مفید است.
		
		
			
			\item 
			\textbf{صرفه‌جویی در حافظه:} ریسمان‌ها به دلیل اشتراک منابع، به فضای کمتری نسبت به فرایندها نیاز دارند. به این ترتیب، در استفاده از حافظه سیستم صرفه‌جویی می‌شود و امکان اجرای تعداد بیشتری از ریسمان‌ها وجود دارد.
		\end{enumerate}
	\end{qsolve}
	
	
	
	\item 
	وظایف (\lr{tasks}) می‌توانند به دو صورت موازی و هم‌روند اجرا شوند. تفاوت این دو روش را توضیح دهید.

	\begin{qsolve}
		\begin{enumerate}
			\item 
			\textbf{اجرای موازی:}\\
			\begin{itemize}
				\item 
				در این روش، وظایف به‌طور واقعی و هم‌زمان روی چندین پردازنده یا هسته اجرا می‌شوند.
				
				\item 
				برای انجام تسک‌ها به‌صورت موازی، نیاز به سخت‌افزاری داریم که از چندین پردازنده یا هسته پشتیبانی کند، مثل پردازنده‌های چند‌هسته‌ای یا سیستم‌های چند‌پردازنده‌ای.
				
			\end{itemize}
			
		\end{enumerate}
	\end{qsolve}
	
	
	
	\begin{qsolve}[ادامه پاسخ]
		\begin{enumerate}
			\item [ ]
			\begin{itemize}
				\item 
				در موازی‌سازی، هر وظیفه در یک پردازنده یا هسته جداگانه اجرا شده و می‌تواند هم‌زمان پیش برود. این روش به‌ویژه برای پردازش‌های سنگین و وظایفی که به سرعت بالا نیاز دارند، مناسب است. برای مثال، یک سیستم پردازش تصویر می‌تواند از موازی‌سازی استفاده کند تا هر هسته پردازنده بخشی از تصویر را به‌صورت مستقل پردازش کند.
			\end{itemize}
		\end{enumerate}
		
		\begin{enumerate}
			\item [(ب)]
			\textbf{اجرای هم‌روند:}\\
			\begin{itemize}
				\item 
				در این روش، وظایف به‌صورت تکه‌تکه اجرا شده و به‌صورت متناوب به یکدیگر سوئیچ می‌کنند؛ یعنی هر وظیفه بخشی از زمان پردازنده را می‌گیرد، سپس وظیفه دیگری اجرا می‌شود.
				
				\item 
				هم‌روندی نیاز به پردازنده‌های چند‌هسته‌ای ندارد و می‌تواند حتی در یک پردازنده‌ی تک‌هسته‌ای نیز اجرا شود. در این حالت، پردازنده بین وظایف مختلف جابجا می‌شود تا احساس هم‌زمانی به وجود بیاید.
				
				\item 
				هم‌روندی معمولاً برای وظایفی که به‌طور هم‌زمان به منابع مختلف نیاز دارند، مانند ورودی/خروجی و محاسبات، کاربرد دارد. برای مثال، یک برنامه چت می‌تواند پیام‌های ورودی و خروجی را به‌طور هم‌روند مدیریت کند، حتی اگر تنها یک پردازنده در سیستم وجود داشته باشد.
			\end{itemize}
		\end{enumerate}
	\end{qsolve}
	
	\item 
		انواع مدل‌های چندریسمانی را نام برده و توضیح دهید.
		
		\begin{qsolve}
			\begin{enumerate}
				\item 
				\textbf{مدل \lr{Many-to-One}}\\
				در این مدل، چندین ریسمان سطح کاربر به یک ریسمان سطح هسته نگاشت می‌شوند. مدیریت ریسمان‌ها در سطح کتابخانه‌های ریسمان کاربر انجام می‌شود و سیستم‌عامل نیازی به دخالت مستقیم در مدیریت هر ریسمان ندارد. عیب این مدل در این است که اگر یکی از ریسمان‌ها نیاز به مسدود شدن داشته باشد (مثلاً در حال انتظار برای \lr{I/O})، تمام ریسمان‌ها مسدود می‌شوند زیرا همه به یک ریسمان هسته وابسته هستند. این مدل در برخی از سیستم‌های تک‌پردازنده‌ای به کار می‌رود زیرا پیاده‌سازی آن ساده‌تر است. تصویری از این مدل در ادامه آورده شده است:
				
				
				\begin{center}
					\includegraphics*[width=0.6\linewidth]{pics/img1.png}
					\captionof{figure}{مدل \lr{Many-to-One}}
				\end{center}
			\end{enumerate}
		\end{qsolve}
		
		
		\begin{qsolve}[ادامه پاسخ]
		\begin{enumerate}
			\item [(ب)]
			\textbf{مدل \lr{One-to-One}}\\
			در این مدل، هر ریسمان کاربر به یک ریسمان هسته مرتبط می‌شود.
			هر ریسمان می‌تواند به‌صورت مستقل اجرا شود و از چندپردازنده‌ها نیز به خوبی پشتیبانی می‌کند؛ یعنی ریسمان‌ها می‌توانند در پردازنده‌های مختلف اجرا شوند.
			این مدل اجازه می‌دهد که ریسمان‌ها به‌صورت مستقل از یکدیگر به پردازنده‌ها اختصاص داده شوند، که بهبود عملکرد را در پی دارد.
			نقطه ضعف این مدل این است که ایجاد هر ریسمان کاربر به معنای تخصیص یک ریسمان هسته‌ای است، که ممکن است منابع زیادی را مصرف کند و در صورت افزایش تعداد ریسمان‌ها سربار زیادی ایجاد کند. در دامه تصویری از این مدل آورده شده است:
			
			\begin{center}
				\includegraphics*[width=0.6\linewidth]{pics/img2.png}
				\captionof{figure}{مدل \lr{One-to-One}}
			\end{center}
			
			
			
			\item [(ج)]
			\textbf{مدل \lr{Many-to-Many}}\\
			در این مدل، چندین ریسمان کاربر می‌توانند به چندین ریسمان هسته نگاشت شوند.
			این مدل انعطاف‌پذیری بیشتری دارد و به ریسمان‌ها این امکان را می‌دهد که به‌صورت موازی در چندین پردازنده اجرا شوند.
			در این مدل، کتابخانه‌های ریسمان می‌توانند تعداد زیادی ریسمان کاربر را ایجاد کنند بدون این که سربار زیادی برای سیستم‌عامل ایجاد شود، زیرا فقط تعداد محدودی از این ریسمان‌ها به ریسمان‌های هسته نگاشت می‌شوند.
			این مدل اجازه می‌دهد که اگر یکی از ریسمان‌ها مسدود شد، بقیه ریسمان‌ها بتوانند به اجرا ادامه دهند و کارایی سیستم کاهش نیابد. شکل زیر مثالی از این مدل است:
			
			\begin{center}
				\includegraphics*[width=0.6\linewidth]{pics/img3.png}
				\captionof{figure}{مدل \lr{Many-to-Many}}
			\end{center}
		\end{enumerate}
	\end{qsolve}
	
	
	\begin{qsolve}[ادامه پاسخ]
		\begin{enumerate}
			\item [(د)]
			\textbf{مدل \lr{two-level}}\\
			این مدل ترکیبی از مدل \lr{Many-to-Many} و \lr{One-to-one} است.
			برخی از ریسمان‌های کاربر می‌توانند به یک ریسمان هسته‌ای مستقل نگاشت شوند (مانند مدل یک به یک)، در حالی که سایر ریسمان‌ها به یک یا چند ریسمان هسته‌ای مشترک نگاشت می‌شوند.
			این مدل امکان انعطاف‌پذیری بیشتری در تخصیص و مدیریت ریسمان‌ها فراهم می‌کند و به برنامه‌های خاص اجازه می‌دهد که از هر دو روش استفاده کنند.
			این مدل در سیستم‌هایی به کار می‌رود که نیاز به ترکیب ویژگی‌های هر دو مدل برای بهینه‌سازی کارایی و استفاده از منابع دارند. شکل زیر مثالی از این مدل است:
			
			\begin{center}
				\includegraphics*[width=0.6\linewidth]{pics/img4.png}
				\captionof{figure}{مدل \lr{Two-level}}
			\end{center}
		\end{enumerate}
	\end{qsolve}
		
	\item 
	انواع حالت وضعیت ریسمان‌ها را نام برده و هرکدام را توضیح دهید.
	
	\begin{qsolve}
		\begin{enumerate}
			\item 
			\textbf{حالت (\lr{Ready}):}\\
			در این حالت، ریسمان برای اجرا آماده است و تمامی منابع لازم (به جز پردازنده) را دارد.
			ریسمان در صف آماده قرار دارد و منتظر تخصیص پردازنده است تا اجرای آن آغاز شود.
			ریسمان می‌تواند پس از آزاد شدن پردازنده از حالت آماده به حالت اجرا منتقل شود.
			
			\item 
			\textbf{حالت (\lr{Running}):}\\
			در این حالت، ریسمان به پردازنده اختصاص داده شده و در حال اجرای دستورالعمل‌های خود است.
			یک ریسمان در هر لحظه فقط زمانی می‌تواند در حالت اجرا باشد که به پردازنده دسترسی داشته باشد.
			اگر اجرای ریسمان به دلیل اتمام زمان پردازنده یا درخواست منابع دیگر متوقف شود، ریسمان به حالت دیگری منتقل می‌شود.
			
			
			\item 
			\textbf{حالت (\lr{Blocked}):}\\
			زمانی که ریسمان نیاز به دسترسی به منبعی دارد که در حال حاضر در دسترس نیست (مثل یک عملیات ورودی/خروجی یا انتظار برای قفل)، به حالت مسدود می‌رود.
			در این حالت، ریسمان نمی‌تواند اجرا شود و باید منتظر بماند تا منبع مورد نیازش آزاد شود.
			هنگامی که منبع در دسترس قرار گرفت، ریسمان از حالت مسدود به حالت آماده باز می‌گردد.
			
						
			
			\item 
			\textbf{حالت (\lr{Terminated}):}\\
			زمانی که ریسمان تمام وظایف خود را به پایان رسانده و دیگر نیازی به اجرا ندارد، به حالت پایان‌یافته می‌رود.
			در این حالت، منابعی که توسط ریسمان استفاده شده بودند آزاد می‌شوند و ریسمان از چرخه‌ی پردازش حذف می‌شود.
			این حالت نشان می‌دهد که چرخه عمر ریسمان به پایان رسیده است.		
		\end{enumerate}
	\end{qsolve}
	
	
	\begin{qsolve}[ادامه پاسخ]
		\begin{enumerate}
			\item [(ه)]
			\textbf{حالت در انتظار (\lr{Waiting}) یا خواب (\lr{Sleep}):}\\
			در برخی سیستم‌ها، حالت در انتظار یا خواب به عنوان یک حالت جداگانه برای زمانی که ریسمان منتظر یک رویداد خاص (مانند یک سیگنال) است، تعریف می‌شود.
			در این حالت، ریسمان تا زمانی که رویداد مورد نظر رخ ندهد، اجرا نخواهد شد.
			پس از وقوع رویداد، ریسمان به حالت آماده باز می‌گردد تا در صف اجرا قرار گیرد.
		\end{enumerate}
	\end{qsolve}
	
	
	\item 
	 \lr{Thread-local storage (TLS)} چیست و در چه مواقعی کاربرد دارد؟ تفاوت آن با متغیرهای داخلی را شرح دهید.
	
	\begin{qsolve}
		\lr{Thread-local storage (TLS)} نوعی مکانیزم ذخیره‌سازی است که به هر نخ امکان می‌دهد متغیرهای خود را به صورت مجزا و مستقل از سایر نخ‌ها ذخیره کند. این ویژگی در مواقعی استفاده می‌شود که بخواهیم داده‌هایی را که تنها برای یک نخ خاص معتبر هستند، ذخیره کنیم تا نخ‌های دیگر به آن دسترسی نداشته باشند و تداخلی ایجاد نشود. این کار از اشتراک‌گذاری ناخواستهٔ داده‌ها میان نخ‌ها جلوگیری می‌کند.
	
	
	از تفاوت‌های آن با متغیرهای داخلی می‌توان به موارد زیر اشاره نمود:
	
	\begin{enumerate}
		\item 
		دامنهٔ دسترسی: متغیرهای داخلی یا محلی فقط در دامنهٔ توابعی که تعریف شده‌اند معتبر هستند و وقتی از آن تابع خارج شویم، این متغیرها دیگر وجود ندارند. در مقابل، متغیرهای TLS برای کل دورهٔ حیات نخ موجود و معتبر هستند.
		
		\item 
		محدودیت به نخ: متغیرهای TLS برای هر نخ به صورت جداگانه اختصاص داده می‌شوند، در حالی که متغیرهای داخلی توسط هر بار فراخوانی تابع در پشته ایجاد می‌شوند و فقط در آن دامنهٔ خاص معتبر هستند.
		
		\item 
		پایداری: متغیرهای TLS در طول اجرای نخ پایدار هستند و با پایان یافتن نخ از بین می‌روند، در حالی که متغیرهای محلی با خروج از بلوک کد یا تابعی که در آن تعریف شده‌اند، پاک می‌شوند.
	\end{enumerate}
	
	\end{qsolve}
	
	\item 
	انواع روش‌های \lr{thread termination} را نام برده و هرکدام را مختصر توضیح دهید.
	\begin{qsolve}
		\begin{enumerate}
			\item 
			\textbf{\lr{:Voluntary Termination}}\\
			در این روش، نخ به صورت خودخواسته و از طریق اجرای دستورات برنامه، به پایان می‌رسد. این حالت معمولاً زمانی اتفاق می‌افتد که نخ کار خود را به پایان رسانده و نیاز به ادامهٔ اجرا ندارد. برنامه‌نویس می‌تواند با فراخوانی تابعی مثل \texttt{pthread\_exit} در \texttt{POSIX} یا \texttt{ExitThread} در ویندوز، نخ را به صورت ایمن خاتمه دهد.
			
			
			\item 
			\textbf{\lr{:Forced Termination}}\\
			در این روش، نخ بدون اطلاع و خواست خود توسط نخ دیگری خاتمه می‌یابد. برای مثال، نخ مادر می‌تواند یک نخ فرزند را به اجبار متوقف کند. این روش ممکن است موجب ناپایداری برنامه شود، زیرا ممکن است نخ در حال اجرای کدی مهم باشد و به طور ناگهانی متوقف شود. توابعی مانند \texttt{pthread\_cancel} در \texttt{POSIX} برای این نوع خاتمه استفاده می‌شوند.
		\end{enumerate}
	\end{qsolve}
	
	
	\begin{qsolve}[ادامه پاسخ]
		\begin{enumerate}
			\item [(ج)]
			\textbf{\lr{:Termination Due to Error}}\\
			زمانی که خطایی در نخ رخ دهد و ادامه اجرای نخ بی‌معنی شود، نخ خاتمه می‌یابد. برای مثال، اگر نخ به منابعی دسترسی نداشته باشد یا به یک وضعیت بحرانی برسد که نمی‌تواند از آن عبور کند، ممکن است خاتمه یابد.
			
			
			\item [(د)]
			\textbf{\lr{:System Termination}}\\
			این نوع خاتمه زمانی اتفاق می‌افتد که سیستم یا پردازش اصلی که نخ در آن اجرا می‌شود، پایان یابد. با خاتمهٔ پردازش اصلی، تمام نخ‌های مربوط به آن پردازش نیز به پایان می‌رسند.
		\end{enumerate}
	\end{qsolve}
	
\end{enumerate}