

\section{سوال سوم}

\begin{enumerate}
	\item 
	 \lr{race condition} چه مواقعی پیش می‌آید و باعث چه مشکلی می‌شود؟ چطور می‌توان از آن جلوگیری کرد؟

	\begin{qsolve}
		\lr{Race condition} زمانی رخ می‌دهد که دو یا چند نخ یا فرآیند به طور همزمان به یک منبع مشترک (مانند یک متغیر یا فایل) دسترسی پیدا کرده و تلاش کنند عملیات خواندن یا نوشتن را روی آن انجام دهند. اگر دسترسی همزمان به منبع به درستی مدیریت نشود، ممکن است نتایج ناخواسته و غیرقابل پیش‌بینی به وجود آید.
	
	
	از مشکلات ایجاد شده توسط \lr{Race Condition} می‌توان به موارد زیر اشاره کرد:
	
	\begin{enumerate}
		\item 
		\textbf{نتایج نادرست:} چون عملیات نخ‌ها به صورت غیرقابل پیش‌بینی انجام می‌شود، ممکن است نتیجه نهایی برنامه اشتباه باشد. مثلاً، اگر دو نخ همزمان مقدار یک متغیر را افزایش دهند، نتیجه ممکن است نادرست باشد، زیرا هر کدام مقدار قدیمی را می‌خوانند و تغییر می‌دهند، بدون توجه به تغییرات دیگری.
		
		
		\item 
		\textbf{ناپایداری در برنامه:} وجود race condition می‌تواند باعث رفتارهای ناپایدار و سخت برای پیش‌بینی در برنامه شود که دیباگ کردن و رفع مشکلات را بسیار دشوار می‌کند.
	\end{enumerate}
	
	برای جلوگیری از این مشکل باید دسترسی نخ‌ها و فرآیندها به منابع مشترک را مدیریت کرد. روش‌های رایج عبارتند از:
	
	\begin{enumerate}
		\item 
		\textbf{قفل‌ها (\lr{Locks}):} استفاده از قفل‌ها (مثل \lr{mutex}) مانع از دسترسی همزمان نخ‌ها به منابع مشترک می‌شود. هر نخ باید قبل از دسترسی به منبع قفل را بگیرد و پس از اتمام کار آن را آزاد کند. این کار تضمین می‌کند که فقط یک نخ در هر لحظه به منبع دسترسی داشته باشد.
		
		
		\item 
		\textbf{متغیرهای شرطی (\lr{Condition Variables}):} متغیرهای شرطی به نخ‌ها اجازه می‌دهند منتظر شوند تا شرط خاصی برقرار شود. این روش به نخ‌ها کمک می‌کند تا فقط در زمان مناسب به منبع دسترسی پیدا کنند و تداخلات را کاهش می‌دهد.
		
		
		\item 
		\textbf{سمافور (\lr{Semaphores}):} سمافورها مکانیزم دیگری برای هماهنگ کردن دسترسی به منابع مشترک هستند و به ویژه در برنامه‌هایی که به دسترسی همزمان محدود به تعداد خاصی از نخ‌ها نیاز دارند، کاربرد دارند.
		
		
		\item 
		\textbf{بخش‌های بحرانی (\lr{Critical Sections}):} استفاده از بخش‌های بحرانی به برنامه‌نویس اجازه می‌دهد تا کدی را که نیاز به دسترسی انحصاری دارد، به عنوان یک بخش بحرانی تعریف کند و فقط یک نخ در هر زمان اجازه ورود به این بخش را داشته باشد.
		
		
		\item 
		\textbf{استفاده از ساختارهای داده‌ای همگام‌سازی شده:} بسیاری از زبان‌های برنامه‌نویسی ساختارهای داده‌ای همگام‌سازی‌شده‌ای مثل صف و پشته را ارائه می‌دهند که به طور خودکار از تداخل‌های نخ‌ها جلوگیری می‌کنند.
	\end{enumerate}
	
	\end{qsolve}
	
	
	
	
	\item 
	در قطعه کد زیر توضیح دهید \lr{race condition} در کدام قسمت ممکن است به وجود بیاید و یک سناریو که باعث ناسازگاری داده می‌شود مثال بزنید.
%source: https://www.uio.no/studier/emner/matnat/ifi/IN3000/v23/timeplan/threads-criticalsections.pdf
%page: 17
	
\begin{latin}
\begin{lstlisting}[caption=Code of Q2, label=cpp_code_example]
int shared_counter = 0;

void* increment_counter(void* arg) 
{
	for (int i = 0; i < 1000000; ++i) 
	{
		shared_counter++;
	}
	return NULL;
}

int main() 
{
	pthread_t thread1, thread2;
	pthread_create(&thread1, NULL, increment_counter, NULL);
	pthread_create(&thread2, NULL, increment_counter, NULL);
	
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);
	
	printf("Final value of shared_counter: %d\n", shared_counter);
	return 0;
}
\end{lstlisting}
\end{latin}
	
	
	
	
	
	\begin{qsolve}
		در قطعه کد ارائه‌شده \lr{Race Condition} می‌تواند در بخش دسترسی و تغییر مقدار متغیر مشترک \texttt{shared\_counter} در تابع \texttt{increment\_counter} رخ دهد. دلیل این مشکل این است که دو \lr{Thread} به صورت همزمان و بدون هماهنگی به متغیر مشترک دسترسی دارند و آن را افزایش می‌دهند.
		
		در این برنامه، دو رشته (\texttt{thread1} و \texttt{thread2}) به صورت همزمان اجرا می‌شوند و هرکدام یک میلیون بار مقدار \texttt{shared\_counter} را افزایش می‌دهند. هر رشته زمانی که به خط \texttt{shared\_counter++} می‌رسد، باید مراحل زیر را انجام دهد:
		
		\begin{enumerate}
			\item مقدار فعلی \texttt{shared\_counter} را بخواند.
			\item یک واحد به مقدار خوانده‌شده اضافه کند.
			\item مقدار جدید را در \texttt{shared\_counter} ذخیره کند.
		\end{enumerate}
		
		از آنجایی که این مراحل به صورت مجزا انجام می‌شوند، ممکن است دو رشته همزمان مقدار \texttt{shared\_counter} را بخوانند، آن را افزایش دهند و مقدار جدید را در متغیر \texttt{shared\_counter} ذخیره کنند. این امر باعث از دست رفتن بعضی از تغییرات می‌شود.
		
		
		برای مثال می‌توان سناریوی زیر را درنظر گرفت:
		
		فرض شود مقدار اولیه \texttt{shared\_counter} برابر 5 است و هر دو رشته به صورت همزمان مقدار فعلی \texttt{shared\_counter} را می‌خوانند. هر دو مقدار 5 را می‌خوانند. هر رشته یک واحد به مقدار خوانده‌شده اضافه می‌کند و مقدار 6 را به \texttt{shared\_counter} اختصاص می‌دهد. در نتیجه، به جای آنکه \texttt{shared\_counter} به 7 برسد، همچنان 6 خواهد بود.
		
		این ناسازگاری داده به دلیل عدم هماهنگی در دسترسی به متغیر مشترک و عدم استفاده از روش‌های همگام‌سازی رخ می‌دهد.
	\end{qsolve}

\end{enumerate}