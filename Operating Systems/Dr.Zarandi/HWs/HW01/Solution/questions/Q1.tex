\section{سوال اول}
به سوالات زیر در مورد دستگاه های ورودی و خروجی و نحوه انتقال اطلاعات از آنها پاسخ دهید.
\begin{enumerate}
	\item 
	وظیفه کنترلر و درایور دستگاه ها چیست؟ تعامل این دو قسمت با یکدیگر و با دستگاه مربوط به خودشان از آغاز تا پایان یک عملیات \lr{I/O} به چه صورت است؟
	
	\begin{qsolve}[]
کنترلر، سخت‌افزاری است که به طور مستقیم با دستگاه \lr{I/O} تعامل دارد. این قطعه، دستورات و سیگنال‌های کنترلی را از سیستم عامل دریافت می‌کند و آن‌ها را به زبان و فرمت قابل فهم برای دستگاه تبدیل می‌کند. همچنین اطلاعات را از دستگاه به سیستم برمی‌گرداند. کنترلر عملاً مانند واسطه‌ای است که باعث می‌شود سیستم عامل بتواند با دستگاه‌های جانبی ارتباط برقرار کند. در شکل زیر نقش کنترلر های \lr{I/O} برای ارتباط با کامپیوتر مشهود است.
	\begin{center}
		\includegraphics*[width=0.8\linewidth]{pics/img1.png}
		\captionof{figure}{نقش کنترلر ها در سیستم}
	\end{center}
	
	درایورها نرم‌افزارهایی هستند که وظیقه آن‌ها ایجاد هماهنگی بین سیستم‌عامل و کنترلر است  درایور، سیگنال‌ها و دستورات سیستم عامل را به فرمت مورد نیاز کنترلر و دستگاه ترجمه می‌کند و به کنترلر ارسال می‌کند. در واقع، بدون وجود درایور، سیستم عامل نمی‌تواند مستقیماً با کنترلر و در نتیجه دستگاه ارتباط برقرار کند. \href{https://www.geeksforgeeks.org/device-driver-and-its-purpose/}{\textcolor{magenta}{[مرجع]}}

	برای مثال یک برنامه که عملیات \lr{I/O} را انجام می‌دهد فرض کنید. برای شروع یک عملیات \lr{I/O}، درایور دستگاه رجیستر‌های مناسب را در کنترلر دستگاه بارگذاری می‌کند. کنترلر دستگاه به نوبه خود محتوای این ثبات‌ها را بررسی می‌کند تا تعیین کند که چه اقدامی انجام دهد (برای مثال «خواندن یک کاراکتر از صفحه‌کلید»). کنترلر انتقال داده از دستگاه به بافر محلی خود را آغاز می‌کند. هنگامی که انتقال داده تکمیل شد، کنترلر دستگاه به درایور دستگاه اطلاع می‌دهد که عملیات خود را به پایان رسانده است. سپس درایور دستگاه کنترل را به سایر بخش‌های سیستم‌عامل واگذار می‌کند و احتمالاً داده‌ها یا اشاره‌گری به داده‌ها را در صورت انجام عملیات خواندن برمی‌گرداند. 
	\end{qsolve}
	
	
	\begin{qsolve}
		برای سایر عملیات‌ها، درایور دستگاه اطلاعات وضعیت مانند «نوشتن با موفقیت انجام شد» یا «دستگاه مشغول است» را بازمی‌گرداند. کنترلر از طریق \lr{interrupt} به درایور دستگاه اطلاع می‌دهد که عملیات خود را به پایان رسانده است. این فرایند در شکل زیر آورده شده است:
		
		\begin{center}
			\includegraphics*[width=0.8\linewidth]{pics/img2.png}
			\captionof{figure}{فرایند ارتباط \lr{I/O} با \lr{CPU}}
		\end{center}
		
	\end{qsolve}
	
	
	
	
	
	
	\item 
	میدانیم یک روش انتقال داده بین دستگاه های ورودی و خروجی و پردازنده، مبتنی بر وقفه هاست. عیب این روش چیست و چگونه در سیستم های کامپیوتری امروزی رفع شده است؟
	
	\begin{qsolve}[]
		یکی از عیب‌های عمده روش انتقال داده بین دستگاه های \lr{I/O } و \lr{CPU} این است که وقفه‌ها به صورت مکرر توسط دستگاه‌های مختلف متصل به سیستم رخ می‌دهند. بنابر این این وقفه‌ها باید مدیریت شوند تا از تداخل وقفه‌ها با یکدیگر جلوگیری شود. این مدیریت در کامپیوتر‌های امروزی به‌صورت زیر رفع شده است:
		
		\begin{enumerate}
			\item 
			کامپیوتر‌های امروزی قادر به تاخیر انداختن مدیریت وقفه‌ها در طول پردازش‌های بحرانی و مهم هستند. یعنی به وقفه‌ها اولویت داده می‌شود و وقفه‌هایی با اولویت بالا تر در اولویت سرویس‌دهی قرار دارند. اکثر \lr{CPU} ها دو خط درخواست وقفه دارند. یکی وقفه \lr{nonmaskable interrupt} است که برای رویدادهایی مانند خطاهای حافظه غیرقابل بازیابی رزرو شده است. خط وقفه دوم \lr{maskable} است. این خط می‌تواند توسط \lr{CPU} قبل از اجرای توالی‌های بحرانی دستورالعمل‌ها که نباید وقفه‌ای در آن‌ها ایجاد شود، خاموش شود. وقفه \lr{maskable} توسط کنترل‌کننده‌های دستگاه برای درخواست سرویس استفاده می‌شود.
			
		\end{enumerate}
	\end{qsolve}
	
	\begin{qsolve}
		\begin{enumerate}
			\item [(ب)]
			مشکل بعدی این است که درخواست‌های بالای سرویس‌دهی وقفه می‌تواند پردازنده را مدام مشغول رسیدگی به درخواست‌های وقفه کند بنابر این بخش زیادی از توان پردازشی پردازنده صرف رسیدگی به این درخواست‌ها می‌شود. برای رفع این مشکل، در کامپیوتر‌های امروزی برای انتقال حجم بالای داده بین دستگاه‌های \lr{I/O} و حافظه بدون نیاز به مداخله پردازنده، از تکنیکی به نام \lr{DMA} استفاده می‌شود. در این روش، یک کنترلر خاص به نام کنترلر DMA عملیات انتقال داده را مدیریت می‌کند و پس از اتمام کار، تنها یک وقفه به پردازنده ارسال می‌کند. این کار باعث کاهش تعداد وقفه‌ها و در نتیجه آزادسازی پردازنده برای سایر وظایف می‌شود.
		\end{enumerate}
	\end{qsolve}
\end{enumerate}


